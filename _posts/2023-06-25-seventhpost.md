---
layout : post
title : "JAVA(3)"
subtitle: "개념 정리"
excerpt: "JAVA 개념 정리"
categories: _JAVA

tags : [developer, blog, git,Github,jvm,java,gc,oop]

toc: true 
toc_sticky : true
comments : true
date : 2023-06-25
last_modified_at : 2023-06-25
---




**절차지향 프로그래밍 / 객체지향 프로그래밍 / 함수형 프로그래밍**

 

절차지향 프로그래밍

>실행하고자하는 절차 정하고, 절차대로 프로그래밍

 

객체지향 프로그래밍

>연관 변수, 메서드를 그룹으로 묶어 클래스(개념) 구현,  상호작용을 프로그래밍

 

함수형 프로그래밍

>문제를 작은 문제로 나누고, 작은문제를 순수 함수로 만들어  순수함수를 조합하여 프로그램으로 만드는 선언형 프로그래밍

 
<br/><br/> 
 

**절차지향 프로그래밍**

 

:프로시저(루틴, 하위 프로그램, 서브루틴, 메서드, 함수 등)를 이용하여 작성하는 프로그래밍 방식

 프로시저 콜(함수 호출)의 개념을 바탕으로 한 프로그래밍 패러다임 


 
 <br/><br/> 

 
 

**절차지향 프로그래밍 장단점**

 

장점 :

- 개체를 순차적으로 처리 , 프로그램 전체가 유기적 연결 

- 컴퓨터의 처리구조와 유사 , 실행속도 빠름 

 

단점: 

 - 모든 프로그래밍 순차적 실행 - 오류 발생시 찾기 어렵고, 유기적 연결로인해 부분 오류가 전체 수정으로 이어질 수 있다

 - 코드의 순서가 있어야하여 융통성이 부족하여 생산성이 떨어짐 


 
 <br/><br/> 

 
 

**객체지향 프로그래밍**

: 프로그래밍에 필요한 데이터의 상태와 행위를 객체로 만들어 , 객체간 상호작용을 통해 비지니스 로직 구성 (OOP)


  <br/><br/> 
  

**객체지향 프로그래밍 장단점**

 

장점 : 

 - 객체를 이용하여 (클래스) 코드 재사용 용이, 상속 통한 확장 가능

 - 클래스 단위로 모듈화, 세분화할 수있어 유지보수 용이, 분업에 좋다

 

단점 :

 - 객체가 많아질수록 용량 커짐

 - 객체를 올바르게 설계하는데 많은 노력과 시간 필요


 
 <br/><br/> 

 
 

**객체지향 프로그래밍 특징** 

 

> OOP 특징  <상속, 추상화, 캡슐화, 댜형성 >

 

 - 상속 : 자식클래스가 부모클래스의 기능 ,상태 물려받아 그대로사용 , 필요한 부분 수정

 

 - 추상화 : 불필요한 부분 삭제 후 필요한 핵심만 정의해두는 것 , 사물을 추상한 후 필요객체 상속받고 필요에 맞게 기능 재정의 사용 0

 

 - 캡슐화 : 비슷한 속성과 메소드들을 하나의 클래스로 모은것 , 외부 접근으로부터 데이터 지킴

 

 - 다형성 : 같은 이름 다른 기능 구현 , ex)오버로딩,오버라이딩, 인터페이스와 연관 


 
 <br/><br/> 
 
 

※ Spring- OOP

 

> spring에서 관리하는 Bean이용하여 객체 의존성 주입하는것이 oop핵심

  객체는  주입받은 객체 직접 관리 X ,어떻게 구현되는지 알 필요 X  어떤기능이 있는지만 알면 0 



 
 <br/><br/> 

 
 

**함수형 프로그래밍** 

 

- 주어진 문제 작은 문제로 나눈 후 , 작은 문제를 순수 함수로 만들어 순수함수 조합하여 프로그램 생성하는 선언형프로그램

 

- 어떻게 하는지 보단, 무엇을 할건지 중심으로 설명

 

- “들어오는 Input에 대해, 원하는 결과값이 무엇(What)이다” 정의한 함수들 상태를 변화시키지 않고, 함수의 응용과

 

   조합으로 프로그래밍을 유도, Side-Effect(예상하지 못한 원치않은 결과) 최대한 줄여 , 신뢰성있는 순수함수 만드는것 



 
 <br/><br/> 
 
 

**함수형 프로그래밍 장단점** 

 

장점 : 

절차지향기법과 달리, 사용하는 모든 데이터가 변경 불가, 함수는 부수효과 가지지X 

공유 데이터에 대한 동시성 접근 문제에 비교적 자유롭다

 

단점 : 

모든 설계를 순수함수로 나누어 ,유기적 설계해야함, 로직이 커질수록 생각할 부분 많아지며

잘못된 설계 = 효율 감소 



 
 <br/><br/> 

 
 

**객체지향 프로그래밍 설계 원칙 (SOLID)**

 

- 단일 책임 원칙 (SRP): 모든클래스는 각 하나의 책임만 가져야한다. 클래스는 그책임을 완전한 캡슐화해야한다

 

- 개방 /폐쇄 원칙 (OCP) : 확장에는 열려있고 수정에는 닫혀있는. 기존의 코드를 변경하지 않으면서( Closed), 기능을 추가할 수 있도록                                             (Open) 설계가 되어야 한다는 원칙

 

- 리스코프치환 원칙 (LSP) : 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙

                                 (부모클래스는 자식클래스가 될수 0)

 

- 인터페이스 분리 원칙 (ISP):  하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다.

 

- 의존관계 역전 원칙 (DIP): 추상화 의존0, 구현체의존X

 

 
 <br/><br/> 

 
 

**Call By Value VS Call By Reference**

 

Call By Value ?

 

> 기본 자료형 변수를 복사하는 경우 발생 

> 기본 자료형 변수는 저장하고 있는 값을 값 자체로 해석, 두개의 변수 서로 영향 X

 

장점 : 복사하여 처리 = 안전 ,원래 값 보존0

단점 : 복사하기 때문에 메모리 사용량 증가

 

 

Call By Reference?

 

> 객체 저장하고 있는 객체 참조변수 복사하는 경우 발생

> 참조 자료형 변수는 저장하고 있는 값을 주소로 해석, 변수가 같은 객체 참조0

 

장점 : 복사하지 X 직접 참조 하여 빠름

단점 : 직접 참조하기에 원래 값 영향 받는다 (리스크)




 
 <br/><br/> 


 
 

**JAVA 호출방식** 

 

> 함수에 전달되는 인자의 데이터 타입에 따라 (원시자료형/참조자료형) 호출방식 달라짐

 

* 원시 자료형 (Primitive type): call-by-value로 동작 (int,short,long,float,double,char,boolean)

 

* 참조 자료형(Reference type): call-by-reference로 동작 (Array, Class,Instance)


  <br/><br/>

  

**try - catch문 유의점

 

- try - catch문 통해 예측가능한 에외 처리 중요하지만, 예외 발생시 try블럭 내 나머지 코드들 수행되지 X 점 유의

- 모든 예외는 Exception 클래스의 자손, catch 블럭 최상단에  Exception선언 시 어떠한 에러든 해당 catch블럭에서 처리



 

  <br/><br/>


  

 

**String VS String Buffer VS String Builder**

 

String

 

- 불변성을 가진 객체

 

- +나 문자열 수정/삽입 하는 경우 새로운 문자열 생성

 

 

String Buffer / String Builder

 

- 문자열 객체를 버퍼에 임시저장

 

- 수정/삭제/삽입 시 버퍼에 저장된 문자열 객체 수정

 

- ToString()에서 메서드로 문자열 반환

 

차이점 

 

- 동기화 유무 ( 스레드 세이프- 멀티 스레드 동시접속 시 문제 X특징)

 

- StringBuffer - 동기화를 지원하기 X, 멀티 스레드환경헤서 사용

 

- SringBuilder - 동기화를 지원하지 X, 단일 스레드환경에서 사용

 

- StringBuilder는 동기화를 지원하지 X, 속도면에선 StringBuffer 보다 성능이 좋다



 
 <br/><br/> 


 
 

**String / String Buffer / String Builder 사용 적절할때**

 

String

> 변하지 X 문자열 자주 사용 시

 

String Buffer

> 단일 스레드 환경과 문자열 추가/삭제/수정 등 빈번히 발생하는 경우 String Builder 사용하는게 성능면 유리

 

String Builder

>동기화 지원, 멀티 스레드 환경에서  안전 동작 

> 멀티 스레드 환경, 문자열 추가/수정/삭제 등 빈번 발생 경우 String Buffer 사용하는 게 성능면 유리





  <br/><br/> 




  

**Map vs HashMap / LinkedList vs Array/ Stack vs Queue**

 

Map 인터페이스 종류

 

맵

- key 와 Value 집합 구조, 중복X

- key 중복 X , 순서 저장 X

- Red-Black Tree 알고리즘 이용

 

해쉬맵

- Map인터페이스에 따르며, 맵 특징 가져감

- Hash Table 이용 , key-value값 저장 

 

트리맵 

- 중복 X

- key 값들 정렬

 

해쉬테이블 맵

- key 와Value 값 Null 허용X

 

링크드 해쉬맵

- 저장 순서 유지



  <br/><br/>
  

Array vs LinkedList

 

Array

- 선언시 Size 고정

- 각 데이터 요소들 인접위치 저장

- 데이터 읽을 때 , index 통해 읽어 조회속도 빠름

- 삽입/ 삭제 시 데이터들은 삭제나 ,삽입이 일어난 index보다 큰 인덱스 가진값 모두 이동시켜야하기 때문에 O(n)가짐

 

LinkedList

- 자료의 주소값을 가지는 노드가 인접해있는 노드 위치를 가르키고있는 구조

- 가르키는 위치만 변경하면 됨 (삽입 ,삭제 시 시간복잡도 0(1))

- 데이터 조회 시 , 루트노드부터 순차적 탐색 

 

 
 <br/><br/> 
 
 

Stack vs Queue

 

Stack 

 

- 후입 선출

- top을 통해 삽입 /삭제 (입구 한개)

- 후위표기식, 괄호검사, 역순문자열, 웹 브라우저 방문기록( 뒤로가기) 활용

 

Queue

 

- 선입 선출

- 삭제연산 front, 삽입연산 rear 두가지 방향 

- 순차적 업무 활용

 

