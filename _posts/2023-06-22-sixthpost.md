---
layout : post
title : "JAVA(2)"
subtitle: "개념 정리"
excerpt: "JAVA 개념 정리"
categories: _JAVA

tags : [developer, blog, git,Github,jvm,java,gc,oop]

toc: true 
toc_sticky : true
comments : true
date : 2023-06-22
last_modified_at : 2023-06-22
---

**정적 타입 언어 VS 동적 타입언어**

 

-정적 타입 언어 : 타입(자료형)의 결정을 컴파일 할때 결정(Java,C,C++)

-동적 타입 언어 : 런타임 과정에서 결정 (Python,JavaScript,Ruby)

 <br/><br/> 
 



**정적타입/동적타입 언어 장단점**  

 

정적 타입 언어 :

컴파일 때 미리 타입 결정 - 실행 속도 빠름 , 에러 문제 초기에 발견 0 ,타입 안정성 높다

동적 타입 언어: 

런타임까지 타임 결정 끌고 가 유연성 높음, 컴파일시 타입 명시 X 빠르게 코드 작성 0

런타임 시 확인 하기 때문에 코드가 길고, 복잡, 타입 에러 찾기어렵다

  <br/><br/> 


  

**스크립트 언어 VS 컴파일 언어**

 

스크립트 언어 <JavaScript,Python>

: 인터프리터가 한 라인 한라인 기계어로 번역 실행

 > 컴파일 에러- 문법오류 사전 방지 X

 > 운영체제 신경 X 한번 만 작성 

  <br/><br/> 

컴파일 언어<C,C++>

:실행 전 소스코드 컴파일 기계어로 번역 후 파일 실행 

> 기계어로 변환 후 실행 하여 빠름

>컴파일 과정 후 기계어 코드 번역 - 사전검증, 최적화 0

>운영체제에 따라 다르게 작업 0

  <br/><br/> 

  

**JAVA 컴파일? 스크립트?**

 

JAVA 컴파일 언어와 가깝다

:자바 컴파일러가 기계어로 번역

 

※ BUT JAVA 조금 특이

: 자바는 JVM에 의해 기계어로 번역 후 실행 

 >Java는 컴파일 시에 Java Byte Code로 컴파일 되며, 이는 JVM에서 인터프리터 방식으로 동작

C,C++의 컴파일 단계에서 생성되는 완벽한 기계어보다 속도 느리다

(최근 JVM 구현은 JIT 컴파일러 포함 일부구간에서 최적화 수행하여 기계어 코드 생성 후 실행)


  <br/><br/> 

  

**JAVA코드 컴파일 과정** 

 

1.개발자가 자바소스코드 작성- 자바 컴파일러가 자바 소스파일 컴파일

 > 이때 파일은 자바 바이트 코드 파일, 컴퓨터가 읽을 수없는 자바 가상머신이 이해할 수 있는 코드

2.컴파일 된 바이트 코드 JVM의 클래스 로더로 전달

3.클래스 로더는 동적 로딩을 통해 필요 클래스들 로딩, 링크 하여 JVM 런타임 데이터 영역에 올림

 

 >실행엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 실행

 >실행엔진은 바이트 코드를 각 OS가 실행 할 수있게 기계어로 변환



  <br/><br/> 

  

**바이트코드**

: 특정 하드웨어가 아닌 가상머신에서 돌아가는 실행 프로그램을 위한 이진 표현법

 대부분 명령어는 0개 이상 매개변수를 갖는 1바이트 크기 

(=기계어)


  <br/><br/> 

  

**클래스 로더 동작 과정** 

 

- 클래스 파일 가져와 JVM 메모리에 로드

- 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어있는지 검사

- 검사 후 필드, 메서드, 인터페이스 ,, 메서드클래스가 필요로하는 메모리 할당

- 클래스 상수 풀 내 모든 심볼릭 레퍼런스 다이렉트 레퍼런스로 변경

- 클래스 변수들을 적절한 값으로 초기화

 
 <br/><br/>

※ 심볼릭 레퍼런스

:참조할때 클래스의 특정 메모리 주소를 참조관계로 구성한것이 아닌 참조하는 대상의 이름 지칭

  Class 파일이 JVM에 올라가면 심볼릭 레퍼런스는 그 이름에 맞는 객체 주소 찾아 연결

= 실제 메모리 주소가 아닌 이름만 가짐

  <br/><br/>

※ 다이렉트 레퍼런스 변경

:실제 메모리 주소값으로 변경해주는 작업

 
 <br/><br/> 

 
**동적 로딩**

 

: 프로그램 실행시 필요할때 마다 동적으로 메모리 생성, 필요없는 메모리 소멸 

일부 클래스 변경시 전체 어플리케이션을 재컴파일 하지 X , 변경사항이 발생시 적은 작업만으로 처리0



  <br/><br/> 

  

**실행엔진 바이트코드 실행과정**

 

1.인터프리터방식 

- 바이트코드 프로그램 - 한번에 하나 명령어 읽은 후 실행 , 느림

 

2.JIT컴파일러 

- 인터프리터 방식 단점 보완 도입

- 인터프리텅 방식으로 실행- 적절 시점에 바이트코드 전체 컴파일 네이티브 코드로 변경, 인터프리팅 X 네이티브 코드 직접 실행

- JIT컴파일러 사용하는 JVM내부적으로 해당 메서드가 자주 수행되는지 체크, 일정정도 넘길시 컴파일 수행

- JIT컴파일러로 인해 자바 네이티브 언어와 유사한 수준 퍼포먼스 낼수 있다



  <br/><br/> 

  

**Primitive Type VS Reference Type**

 

Primitive Type

:기본 데이터 타입

> 종류 : byte, short, char, float, double, boolean

 

Reference Type

:참조 데이터 타입

> 종류 : Class, Array, Interface, Enumeration

> 값이 저장된 곳 주소 저장

> 4 byte 크기의 주소값 

 

  <br/><br/> 

  

**Primitive Type VS Reference Type 차이점**

 

-기본 데이터 타입 실제 데이터 값 자체 저장

  데이터 크기가 작고 고정적, 메모리 Stack 영역 저장 

-Array와 Class 참조 데이터 타입 - 객체 메모리 상 위치한 주소 저장

  데이터 크기 동적 - 동적 관리하는 Heap영역 저장

-참조 데이터 타입 경우 더이상 참조 변수 없을 시 GC(가비지 컬렉션)에 의해 사라짐

 

  <br/><br/> 

  

**Primitive Type / Reference Type 사용되는 케이스**

 

Primitive Type (기본데이터타입)

:NULL 다루지 X, Generic에 담기지 X

 Reference type 과 비교해 갖는 장점은 성능, 메모리 이점

> Reference type은 스택 메모리에 참조값만 있고 실제 값은 힙메모리 존재

> Reference type은 필요 할때 마다, Primitive Type 과 비해 접근 속도 느려짐

 

Reference Type(참조 데이터 타입)

: 데이터 동적 X 성능과 메모리 장점이 있는 Primitive Type 먼저 고려해보고,

 Null을 다뤄야하거나 Generic 타입에서 사용된다면 Reference Type 사용


 
 <br/><br/> 


 
**JAVA ThreadLocal**

 

> Tread 내부에서 사용하는 지역변수

 

-일반 변수의 수명은 특정 코드 블록 범위내에서 유효 ,ThreadLocal 이용시 쓰레드 영역 변수 설정 가능

-특정 쓰레가다 실행하는 모든 코드에서 쓰레드에 설정된 변수 값 사용 가능 

-멀티 쓰레드 환경에 각 쓰레드마다 ,Get()/Set() 메서드 통해 독립적 변수접근 가능



  <br/><br/> 


  

**ThreadLocal 활용**

 

-한 쓰레드에서 실행되는 코드 동일한 객체 사용할 수 있도록 0

-쓰레드와 관련 코드에서 변수 공유시 파라미터,또는 리턴 값으로 정보 제공하지 X

 

> Ex) Spring Security에서 사용자 인증 정보 사용 

-서버에서 클라이언트 요청들에 대해  각 쓰레드에서 처리하게 될시 , 해당 유저의 인증 , 세션 정보 ,참조 데이터를 저장하는데 사용

 

  <br/><br/> 


  

**ThreadLocal 내부구조**

 

> thread 정보를 key로 하여 값 저장해두는 Map구조

  Ex) get,set 메서드 


  

  <br/><br/> 



  

**ThreadLocal 사용시 주의사항**

 

-Thead의 정보를 key로 하여 Map의 형식으로 데이터를 저장한 후 사용 가능한  자료구조

 만약 ThreadPool을 사용하여 thread를 재활용 시
 동일한 이전에 세팅했던 ThreadLocal의 정보가 남아있어 원치않는 동작을 할 수 있으므로 

 ThreadPool을 사용하는 시  모두 사용 후 THreadLocal의 값을 remove 메서드를 사용하여 값을 제거




  <br/><br/> 



  

**JAVA SE 와 JAVA EE 어플리케이션 차이점**

 

JAVA SE 

:자바 표준 에디션

 

JAVA EE

:JAVA SE의 API에 추가, JSP, Servelt 등의 추가 API를 탑재
